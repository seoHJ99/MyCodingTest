--------------------------
전날 람다 마저

서버리스 컴퓨팅 서비스
단위 : Function
main 한수를 handler 라고 부름. 핸들러 한수는 파라미터 2개를 받음.
첫번째 파라미터는 이벤트 정보. json 형태. 
두번째는 context 정보. 코드를 작동시키기 위한 런타임 정보.

메모리 크기로 cpu 성능, 네트워크 대역폭 등의 리소스를 정함. 즉, 메모리 크기에 따라 요금이 다름. 최대 10gb
시간제한이 있음. 최대 15분.

레이어 : 기존에는 의존되는 라이브러리의 모든 코드가 서버에 배포되었음. => 무겁고 느림. 일관성을 해칠 위험.
        이를 해결하기 위해 여러 람다에서 동일하게 참조하는 라이브러리들을 따로 한데 모아 배포. 이를 레이어라고 함.
        레이어 비용 x

람다에서도 컨테이너 이미지를 실행 가능. fargate 와 달리 구동 가능한 이미지에 제한이 있음.

람다에서 일어나는 일은 CloudWatch 에 저장됨. 따라서 CloudWatch 에 접근 가능하도록 역할이 기본적으로 설정됨.
s3같은 서비스에서 람다를 호출할시, 람다를 호출할수 있도록 리소스 기반 정책을 통한 권한 설정.
반면 람다가 이벤트를 감지하다가 호출되는 경우, 호출 권한이 필요 없음.

람다는 호출되면 cloudWatch 의 invocations에 기록됨.
cloudWatch 에 프로그램 로그 기록됨.
임시 스토리지 10gb 까지 제공. 실행 환경이 구성되면 없어짐.

이벤트에 따라 람다쪽에서 이벤트 주체에게 람다 호출 권한을 줘야하기도 함.
데이터 저장을 위해 EFS 를 사용 가능.
람다 함수 호출 url 을 만들거나 api 게이트웨이 생성.
람다는 한 실행 환경에서 하나의 이벤트만 처리 가능. 즉, 멀티 쓰레드 이벤트 처리가 안됨.
람다는 stateless

람다에서 API 를 호출하는건 죄다 역할.
api 게이트웨이와 연결할시, api 게이트웨이의 접근을 허락하는 리소스 기반 정책이 필요함.

람다 함수 호출방법
동기식(직접 호출) - api 게이트웨이를 이용한 호출. event 정보 역시 api 게이트웨이 정보.
                 - 재시도 안함 
                 - 람도를 호출하기 위한 리소스 기반 정책 필요
비동기식(푸시) - 사용자가 관리 불가능한 이벤트 대기열이 생성됨. FIFO 보장 없음. 이벤트 정보만 저장됨. 대부분 여기 해당
              - 기본 제공 재시도(2번)  
              - 람다를 호출하기 위한 리소스 정책 허락 필요
폴링 기반(풀) - 람다가 이벤트 소스를 주기적으로 확인. 변화가 감지되면 이벤트 정보를 직접 가져와서 처리. 주로 데이터를 저장하는 서비스. 대기열, 스트림이 존재하는 서비스가 해당됨.
               DynamoDB의 스트림 기능 사용시 해당됨.
             - 재시도 여부는 이벤트 소스에 따라 다름
             - 람다가 직접 감시하기 위한 역할 필요.

람다의 런타임 수명주기
람다에서 코드를 실행한 뒤, 바로 종료하는 것이 아니라 일정 시간 사용되지 않더라도 실행환경이 구축된 상태로 유지됨.
덕분에 람다 런타임 환경을 재사용 가능.
1. 호출
2-1. 만약 재사용할수 있는 람다가 없다면 라이브러리 다운, 실행 환경 구축 등 - 콜드 스타트 
2-2. 만약 재사용할수 있는 람다가 있다면 람다 재사용. 더 빠름 - 웜 스타트
3. 코드 실행
4. 재사용을 위한 대기 상태
5. 종료

콜드 스타트 최소화
프로비저닝된 동시성 : 지정된 숫자만큼 미리 프로비저닝된 람다를 실행. 대신 그 숫자만큼 비용 청구
람다 함수 예약 : 특정 시간에 지정된 숫자만큼 실행되도록 예약 가능

람다에 버전에 따라 alias 를 붙이는것이 가능. 하나의 버전에 여러개의 alias 가능.
arn 에 Function 이름과 버전 또는 alias 이 들어감.
버전 번호 혹은 alias 가 없으면 가장 최신 버전이 선택됨.

cli 설명
invocation-type : 호출 타입. event(비동기) 와 requestResponse(동기), dryrun(옳바른 요청인지 확인)

배포 방법
1. zip 파일 - 허용하는 최대 용량이 작음
2. 컨테이너 이미지 - 무거운 코드도 가능

-----------------------------------------------
api gateway

어플리케이션 api 를 관리하는 서비스

일반적인 흐름
1. 요청 : client -> method request -> integreaton request -> 람다, ec2 등
          만약 클라이언트의 요청 그대로 전달한다면 integreaton request 과정이 삭제
          그러나 json 으로 변환하는 것같은 작업이 필요하면 integreaton request 필요
          즉, integreaton request(response) 가 데이터 변환 작업을 한다.
          proxy resource 설정을 통해 integreaton 사용 여부 결정

method request : Authorization, API Key required, Request Validator 으로 구성
                - 에플리케이션에 인증된 사용자인지 여부(aws cognito) - Authorizer
                - api 키
                - model 을 이용해 옳바른 요청인지 검증 - Models


request paths : 요청 경로 설정
mapping templates : 요청 데이터를 변환할때 사용하는 매핑 정보
models 메뉴 : 매핑템플릿 생성시 스키마 정보를 만듬. 

배포될때 stage 이름에 따라 스냅샷이 생성됨.
무조건 하나 수정하면 다시 deploy 해줘야함.

http API : rest api 를 경량화. 하나의 url 에 하나의 기능만 가능
    - 경량화되어 사용하기 편한대신 integreaton 같은 제한사항이 불가능한

프록시 : 변환함
비프록시 : 변환안함
mock 통합 : 테스트 용도

매핑 템플릿 : vtl 이라는 문법 사용 가능. 스키마 정보를 만들어서 옳바른 형식의 요청인지 검증 및 지정된 형식으로 변환에 사용

Swagger 를 사용한 api 설계
swagger : api 스팩을 문서화 시킨것. yaml파일.

canary 릴리스 : 무중단 배포 기법. 소규모 사용자들에게 먼저 배포하여 리스크를 줄이는 기법.
    롤백이 가능하며 리스크가 적다. 클라우드에 특화
    route 53 을 이용해서 구현 가능



-----------------------------------------------------------

aws step Function 을 통한 오케스트레이션

AWS Step Function : 워크플로 오케스트레이션 도구. 순서도.
workflow studio : 업무 흐름을 시각화, 실행 자동화? 가능



---------------------------------
인증 및 권한
통합인증(sso) : 한번 인증 받으면 다른 곳들에서도 가능
페데레이션 : 다른 곳에서 인증 받아서 인증 정보를 제공하면 그에 맞는 aws 서비스를 사용 가능한 역할을 줌

cognito : 에플리케이션에 대한 인증. 페데레이션에 사용
    - 사용자 풀과 자격 증명 풀
    - 사용자 풀 : 사용자에 대한 데이터를 저장 + 약간의 기능 추가. oauth 가능. 
    - 자격증명 풀 : aws 서비스에 대한 액세스 권한 부여. 페데레이션 자격 증명. 일반적으로 토큰 사용
    - 인증받은 사용자간 세부적인 차별화가 가능. vvip, vip, 일반 등.



----------------------------------
모니터링
observability : 관측, 분석 등이 포함된 큰 개념
monitoring : 관측. 과거지향적. 작은 개념

관측 가능성의 3대 요소
지표, 로깅, 트레이싱(추적)
CloudWatch(로그, 지표), X-Ray(트레이싱)

cloudWatch 의 지표
표준 : aws 에서 제공.
사용자 지정: 사용자의 필요에 따라 지정하여. agent 설치가 필요.
지표에는 namespace 가 존재. 표준은 보통 서비스 이름. 사용자 지정 지표는 사용자가 직접 지어줌. 기본은 에이전트 이름.
13개월만 저장

cloudWatch 의 경보
임계치를 지정. 이에 따라 이벤트 발생같은 작업이 가능한 기능

로그의 종류
event / stream / group
이벤트  -> 스트림(이벤트의 묶음) -> 그룹(스트림의 묶음)
이벤트 : 말 그대로 이벤트
스트림 : 이벤트가 발생한 일련의 흐름의 묶음
그룹 : 스트림이 발생한 일련의 워트플로우 전체.

로그 수집하기 위해선 agent 설치 필요
람다는 설치 안해도 됨.


x-Ray
관측가능성
x-Ray 는 서비스 맵 생성. 사용자의 서비스 흐름을 분석, 가시화. 장애 발생 위치를 쉽게 찾기 위함.
트레이스 : 사용자가 애플리케이션의 끝단(보통은 db) 까지 이동하는 과정
세그먼트 : api 가 애플리케이션 다음 단계까지 이동하는 과정  ????????????????????????????????
하위 세그먼트 : 애플리케이션의 내부  ??????????????????????????????????????????????????????

이 서비스 역시 x-Ray 데몬 또는 cloudWatch agent 가 필요.
람다는 데몬 필요 없음

x-Ray 를 사용하기 위해선 이에 대한 권한 필요. 역할 할당 요구됨.


-----------------------------------------------------------------------
모던 애플리케이션

마이크로 서비스 / DevOps(개발과 운영을 같이) / 서버리스


-------------------------------------------------------------
배포

DevOps : 방법론. 기술용어가 아님. 기술보다는 사람과 문화에 더 중점. 잦은 배포. 지속적인 개선
    CI/CD : 지속적인 틍합, 지속적인 전달(또는 배포)
    IaC : 코드형 인프라

ci : 빌드까지 자동화
cd : 배포, 운영까지 자동화
파이프라인 : 각 단계들간의 연결

소스단계는 필수.
aws 는 codeCommit 지원(aws 의 git)
나머지 빌드와 배포는 선택사항.

빌드는 codeBuild 서비스.
배포는 codeDeploy 서비스.

이것들을 이어서 파이프라인으로 만드는 것이 codePipeLine

aws config : 리소스의 변경사항을 모두 기록. 태그 강제같은 기능도 가능. 리소스 제어.
asw codeArtifact : aws 의 gradle, maven 같은 서비스


------------------------------------------------------------
AWS SAM(Serverless Application Model)
서버리스 서비스를 쉽게 사용하기 위해 aws 에서 제공하는 서비스.


sam 템플릿은 yaml.
sam cli 가 별도로 존재.

sam 템플릿이 자동으로 aws CloudFormation 템플릿으로 변해서 자동으로 리소스 생성 가능.
이렇게 하나의 템플릿으로 만들어진 서비스들을 모아서 스택.
스택을 삭제하면 모두 삭제됨.
yaml 파일에 Transform: 항목이 존재해야 서버리스
SAM 템플릿 내부에서 곧바로 api 게이트웨이와 연결 가능. 본래는 사용자가 직접 다 해야 했던 일.

sam 워크플로
1. sam init
2. 선택지 선택
3. sam build

본래는 서로 다른 리소스간의 의존 관계를 고려해서 순서대로 만들어야 하지만 sam 을 이용하면 이를 고려하지 않아도 됨.

** CloudFormation 은 병렬적으로 리소스를 생성. vpc보다 ec2가 먼저 만들어질수도 있음.

sa
saa 강의가 따로 있음
daa
daa 강의가 따로 있음
코드 없는 프로그래밍에서 ai에 대한 지식 조금 공부