시스템 스터럭쳐와 프로그램 실행
cpu: 모든 클럭마다 메모리에서 인스트럭션(명령)을 읽어와서 실행
모디 빗 : cpu내부. 운영체제인지 사용자가 실행한 프로그램인지 구분
인터럽트 라인 : 인스트럭션이 끝나면 체크. 
cpu는 오직 메모리하고만 일함
만약 디스크에 접근해야 하면 디스크의 디바이스 컨트롤러(디바이스의 cpu 같은 것)에게 특정 데이터에 대한 접근을 요청
읽으면 로컬버퍼에 넣음.
만약 i/o가 일어나면 cpu는 디바이스 컨트롤러한테 데이터를 가져오게 시키고 그동안 계속 일함.
만약 반드시  데이터가 필요한 작업만 남으면 다른 프로그램 작업을 수행
그러나 만약 무한루프를 도는 프로그램이면 다른 프로그램의 일을 못하는 문제가 발생
이를 해결하기 위해 타이머라는 하드웨어 존재.
타이머는 시간이 종료되면 cpu에 인터럽트를 걸음.
운영체제가 다시 cpu를 얻으면 타이머에 값을 다시 세팅해서 다른 프로그램에 넘김.
이걸 계속 반복.
프로그램은 직접 io에 접근 불가능.
운영체제한테 cpu를 맡기고, cpu가 다시 디바이스 컨트롤러한테 io에 접근, 그리고 운영체제는 기존 프로그램이 아닌 다른 작업에 cpu할당.
만약 io가 들어오면 cpu에 인터럽트 발생. 그리고 처음 io를 요청한 프로그램의 메모리 공간에 io를 카피한 뒤, 중단된 프로그램에 다시 cpu를 할당함. 시간되면 요청한 프로그램에 다시 cpu할당.

모디 빗이 0이면 운영체제가 cpu 에서 수행중, 1이면 사용자 프로그램을 실행중.
모드빗이 0이면 모든 프로그램을 사용 가능. 모디빗이 1이면 제한된 인스트럭션만 실행 가능. 보안상의 이유.
0이면 커널모드, 시스템모드, 모니터 모드라고 부름.
타이머: 특정 프로그램이 cpu를 독점하는 것을 막기 위해. 매 클럭 틱마다 1씩 감소.0이 되면 인터럽트 발생하여 다시 운영체제에게 cpu가 감.
디바이스 컨트롤러: io장치를 컨트롤하는 작은cpu. local buffer를 가짐. 제어 정보를 위한 레지스터
(메모리도 컨트롤러가 있음)
원칙적으로 메모리는 cpu만 접근 가능. 나머지 io는 자기 buffer에만 접근 가능.
그러나 이렇게하면 인터럽트가 너무 많이 생김.
그래서 이를 해결하기 위해 DMA컨트롤러가 존재.
DMA컨트롤러: 직접 메모리 접근 컨트롤로. DMA도 메모리에 접근 가능함. 메모리 컨트롤러는 DMA	컨트롤러와 CPU의 접근에 대한 교통정리. DMA컨트롤러는 io에서 인터럽트가 생길때 cpu는 계속 일하도록 하고, 로컬 버퍼의 내용을 본인이 복사해옴. 그리고 전부 복사해 오면 그때 cpu에 넘김.
디바이스 드라이버: cpu가 디바이스를 실행시키기 위해 필요한 코드를 담고 있음
모든 입출력 명령은 특권 명령. 모드빗 상태 0
따라성 운영체제가 수행해야 함.
사용자 프로그램이 io를 수행하기 위해 운영체제를 호출하는 것을 시스템 콜.
이는 단순히 메모리 주소는 바꾸는 것이 아닌, 사용자 프로그램이 직접 인터럽트 라인을 세팅하는 인스트럭션 시랳ㅇ. 그 이후 cpu는 인터럽트가 발생한 것을 깨닫고 모드빗이 0으로 바뀌고 os에 cpu가 넘어감. 그러면 os에서 디바이스 컨트롤러에 io요청.
소프트웨어 인트럽트.(=트랩)
os는 옳바른 요청인지 확인한 뒤 io수행
io수행 완료시 하드웨어 인터럽트 걸림.
즉,  io요청시엔 소프트웨어 인터럽트가 발생하고, io가 끝났을 시엔 하드웨어 인터럽트 발생.
io컨트롤러는 작업이 끝났음을 cpu에 알리기 위해 인터럽트를 걸음.
시스템 콜 : 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것. 스스로 인터럽트를 검.
인터럽트 벡터 : 해당 인터럽트 종류마다 어디에 있는 함수를 실행해야하는지 메모리 주소를 가지고 있음.
인터럽트 처리 루틴 : 인터럽트 종류에 따라(io인터럽트인지, 소프트웨어인지 등등) 처리하는 방식을 정의해 둠.
