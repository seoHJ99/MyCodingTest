불연속 할당 기법
1. 페이징
2. 세그멘테이션
3. 페이지드 세그멘테이션
패이지 테이블에 프레임 번호 외에 정보가 더 있음.
valid-invalid bit : 비트가 valid 이면 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함. 접근 허용
invalid : 해당 주소의 frame에 유효한 내용이 없음을 뜻함. 접근 불허.
protection bit : page에 대한 접근 권한. 해당 페이지에 대해 read, write 등의 접근이 허락되는지에 대한 권한을 나타냄.

inverted page table : 역방향 페이지 테이블. 물리적 주소를 가지고 논리적 주소를 얻어내는데 사용. n번째 프레임의 m번째 주소의 내용은 페이지 테이블의 n번째 엔트리의 p라는 논리적 메모리 주소를 가지고 있고, 논리적 주소 p에는 m의 데이터가 담겨져 있다.
장점 : 페이지 테이블이 하나만 있어도 여러개의 프로세스를 변환할수 있음.
단점 : 논리 -> 물리 주소변환하기 위해 모든 페이지 테이블 엔트리를 뒤져보면서 로지컬 메모리 주소의 n번째 페이지가 담겨져 있는지 찾아야함. 따라서 페이지 테이블을 쓰는 이유가 없어짐.
해결법 : associatve register 사용. 이를 사용하면 병렬 검색이 가능해져서 검색이 빨라짐. 해결. 그러나 비싸짐.

shared pages
동일한 프로세스가 여러개 실행중일 경우, 코드 부분은 똑같고 데이터 부분만 다름. 따라서 동일한 코드 여러개가 메모리를 차지하는 문제를 해결하기 위해 나온 개념.
read-only로 하여 프로세스간에 하나의 code만 메ㅗㅁ리에 올림. shared code는 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 있어야 함. 즉, 페이징 번호가 같아야 한다. 왜냐하면 코드는 이미 컴파일되어 있기에 기계어가 같다면 논리적 주소까지 같아져야 하기 때문이다.
데이터와 필요에 따라 private code는 각자 따로 올라가기도 한다.

segmentation
의미 단위를 기준으로 논리적 메모리를 분할하여 할당하는 기법. 이 경우 크기가 다 다름.
일반적으로 code, data, stack부분이 하나씩 세그먼트로 정의됨. 크게는 프로그램 하나를, 작게는 함수 하나하나를 세그먼트로 구성 가능.
logical address 는 <segment-number, offset> 로 구성
segment table 은 <limit, base>로 구성
cpu가 a,b라는 논리적 주소를 주면, a를 세그먼트 번호, b를 오프셋으로 봐서 segment table에서 a번째 엔트리로 간 다음 해당 엔트리의 base위치가 물리적 주소에서 세그먼트의 시작지점이 되고, 그 내부에서 b번째가 저장되는 물리적 위치가 됨. base는 몇번째를 뜻하는 것이 아닌 바이트단위 주소여야 함. limit는 세그먼트의 길이(크기)를 나타냄. 만약 오프셋 b가 리미트를 벗어난다면 접근을 허락해주지 않음.
세그먼트 기법에서는 2개의 레지스터를
 Segment-table base register(STRB) : 물리적 메모리에서 segment table의 위치.
 Segment-table length register(STLR) : 프로그램이 사용하는 segment의 수.
를 담고 있다. 만약 논리주소에서 주어진 세그먼트 번호가 segment 개수를 넘어섰다면 막는다.
각 세그먼트 별로 protection bit가 존재함.
세그먼트는 나눠지는 덩어리가 적어서 공간 낭비가 페이지에 비해서 더 심함. 따라서 실제 시스템은 대부분 페이지를 사용한다.
장점 : 의미 단위로 자르기에 공유나 보안에 대해서는 훨씬 효율적임. 예를 들어 stack는 함수를 호출하고 리턴하기 위해 사용하는 공간이기에 read/write가 다 가능해야하나, code는 read만 가능해야 함. 이런 식의 관리를 segmentation에서는 페이지와 다르게 모두 protection bit을 걸 필요가 없다. 공유도 마찬가지.
단점 : 이 역시 hole발생 문제가 생길수 있다. 외부 조각이 생기는 문제.

paged segmentation
기본적으로 세그멘테이션 기법을 사용하나 세그먼트가 여러개의 페이지로 구성되는 방법. 세그먼트 크기가 페이지의 배수가 되도록 한다. 따라서 페이지 단위로 물리적 메모리에 올라가게 됨. 공간 낭비를 줄임. 대신 세그먼트 테이블을 만들어둬 의미 단위로 관리도 가능하도록 함.
세그먼트마다 페이지 테이블이 존재해서 논리적 주소 a, b 의 경우 a는 세그먼트 번호여서 STBR을 통해 세그먼트 위치를 찾고, b는 페이지 번호 + 오프셋 번호가 되어, 세그먼트 테이블에 limit 대신 페이지 테이블이 있어서 세그먼트를 구성하는 페이지들의 위치를 찾아 가는 방식으로 변환한다.
즉, 옳바른 페이지의 b번 위치가 데이터 위치가 된다.

장점 : allocation 문제가 없으며 공유, 보안 역시 segment 의 장점만 사용하게 된다.

이런 식의 물리적 메모리 변환은 모두 하드웨어의 역할