고전적인 세마포어 문제
bounded-buffer problem (producer-consumer problem)
버퍼: 임시로 데이터를 저장하는 공간.
생산자와 소비자 프로세스가 존재.
생산자는 데이터를 생산하여 공유 버퍼에 저장하는 역할.
소비자는 공유버퍼에서 데이터를 빼와서 사용하는 역할.
문제 1. 생산자 둘 이상이 동시에 도착해서 같은 위치에 데이터를 동시에 넣는 것.
해결법 : 공유 데이터에(버퍼 전체) lock를 걸어서 데이터를 넣고 lock를 품. 소비자도 마찬가지.
문제 2. 버퍼가 유한하기에 생기는 문제. 생산자가 한꺼번에 도착해서 버퍼를 모두 채웠음에도 데이터를 더 채워넣어야 하는 상황. 즉, 생산자 입장에서는 사용할수 있는 자원이 없음.
해결법 : 소비자가 데이터를 사용해서 공유 버퍼의 여분이 나올때까지 기다림. 소비자도 마찬가지.
semaphore 변수는 lock을 거는 용도, 그리고 가용자원의 개수를 세는 용도로 사용됨.

readers-writers problem
한 프로세스가 db에 write중일때 다른 process가 접근하면 안됨.
read는 동시에 여럿이 해도 됨.
해결법 :
 writer가 db에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기중인 reader들을 다 db에 접근하게 해준다.
writer는 대기중인 reader가 하나도 없ㅇㅅ을때 db에 접근이 허용된다.
일다 writer가 db에 접근중이면 reader들은 접근이 금지된다.
writer가 db에서 빠져나가야만 reader의 접근이 허용된다.

dining-philosophers problem 식사하는 철학자들 문제
저번 글 마지막 참조.
데드락의 가능성.
해결법 : 철학자가 밥을 먹을때만 앉게함
젓가락을 두게 모두 잡을수 있을때만 젓가락을 집을수 있게 함.
비대칭. 짝수 철학자는 왼쪽 젓가락부터, 홀수는 오른쪽부터 집도록 함.
monitor로 해결 가능.

Monitor
semaphore의 문제
1. 코딩하기 힘들다.
2. 정확성의 입증이 어렵다.
3. 자발적 협력이 필요하다.
4. 한번의 실수가 모든 시스템에 치명적인 영향을 끼친다.
동시 수행중인 프로세스 사이에서 추상 데이터 타입의 안전한 공유를 보장하기 위한 high-level synchronization construct
공유데이터가 존재할때 모니터 내부에 공유데이터와 공유데이터에 접근하는 프로시저를 정의해두고 프로시저를 통해서만 접근 가능하게 해둠. 그리고 내부에 이쓴ㄴ 프로시저가 동시에 실행되지 않도록 설정
모니터는 기본적으로 모니터에 대한 동시 접근을 허용하지 않기에 세마포어와 다르게 사용자가 직접 락을 걸어줄 필요가 없음.
모니터 내에서는 한번에 하나의 프로세스만이 활동 가능.
프로그래머가 동기화 제약조건을 명시적으로 코딩할 필요 없음.
프로세스가 모니터 안에서 기다릴수 있도록 하기 위해 condition variavble를 사용
condition variable : semaphore 의 가용 가능한 자원의 개수를 세는 용도와 비슷한 역할. 대기열 큐에 넣거나 큐에서 꺼내와 깨우는 변수??