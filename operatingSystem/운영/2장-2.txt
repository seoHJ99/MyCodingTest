시스템 구조와 프로그램 실행
인스트럭션이 보통 4바이트
다음 인스트럭션 실행 전 인터럽트 라인을 읽어서 인터럽트가 들어왔는지 확인
인터럽트가 들어오면 무조건 cpu는 운영체제가 가져 감
os는 인터럽트 종류별로 인터럽트를 처리하여 인터럭트 백터에 있는 주소로 이동
trap :  오류에 의한 인터럽트와 시스템콜로 인한 인터럽트

동기식 입출력(synchfonous i/o)
싱크로노스라는 말이 완벽한 번역이 아님
i/o요청 후 입출력 작업이 완료된 후에야 사용자 프로그램에 제어가 넘어감
i/o의 완료는 인터럽트로 알려줌
비동기식 입출력은 완료가 안끝나더라도 프로그램의 다음 작업을 하다가 i/o가 완료되면 i/o가 필요한 작업을 함.

DMA(Direct Memory Access)
본래는 메모리에 접근 가능한 것은 cpu
그러나 이는 i/o장치가 많고 입력값이 많아 인터럽트가 자주 일어남.
이를 해결하기 위해 i/o 장치 내부의 버퍼에 일정량 이상의 데이터(입력)(이 쌓이면 DMA가 버퍼의 내용을 카피한 다음 메모리에 적재한 뒤 인터럽트를 걸어서 cpu가 처리하도록 함.
인터럽트가 줄어듬

입출력 명령어의 종류
i/o를 수행하는 special instruction에 의해
memory mapped i/o에 의해
1 번이 일반적. 메모리만 접근하는 일반 인스트럭션과 i/o로 접근하는 특수 인스트럭션이 나눠져있어 명령으로 구분
2 번은 i/o 장치들에 메모리주소의 연장 주소값을 부여하여 그 주소값이 호출되면 i/o에 대한 접근으로 구분

저장장치 계층 구조
레지스터
캐시 메모리 - 메모리와 레지스터간의 속도 차이를 메우기 위해 존재. 당장 필요한 것만 담고 있음. 이것이 바로 캐싱. 보통 재사용을 목적으로 캐싱함.
메인 메모리
여기까지 휘발성. 비쌈. 빠름. 실행가능. cpu가 직접 접근 가능
------------------
hdd/ssd

프로그램의 실행 (메모리 로드)
실행 파일 실행 -> 메모리 주소 address space 형성됨(코드, 데이터, 스택이로 이뤄짐. 코드는 기계어 코드, 데이터는 전역 변수 등 실행하기 위한 자료구조, 스택은 함수를 담고 있음) (가상 메모리) -> 가상 메모리중 당장 필요한 부분만 진짜 메모리에 올림(메모리 낭비를 막기 위해) -> 그 외의 부분은 디스크의 swap area에 올림

메모리 커널 주소 공간의 내용
코드 : 시스템 콜. 인터럽트 처리 코드. 자원 관리를 위한 코드. 편리한 서비 제공을 위한 코드
데이터 : 운영체제가 사용하는 자료구조의 내용 + 실행중인 프로세스들을 관리하기 위한 자료구조(운영체제가 프로그램 관리)
스택 : 실행중인 프로세스들의 커널 스택(사용자 프로그램들이 시스템 콜을 할수도 있기에)

사용자 프로그램이 사용하는 함수
사용자 정의 함수 : 자신의 프로그램에서 정의한 함수 - 내 프로그램 주소에 존재
라이브러리 함수 : 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수. 자신의 프로그램 실행파일에 포함됨 - 내 메모리 주소에 존재
커널 함수 : 운영체제 프로그램의 함수. 커널함수 호출 = 시스템 콜 - 커널 메모리 주소 공간에 존재
메모리 주소간의 점프가 아님.
메모리 주소를 바꾸는 것은 모두 논리적 메모리 차원에서 말하는 것.

프로그램의 싥행
a 프로그램 실행 -> cpu사용(user 모드) -> 시스템 콜 -> 커널 모드(운영체제가 cpu) -> 뭔가 실행 -> 다시 a

