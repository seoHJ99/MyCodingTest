수퍼블록 : 파일 시스템의 총체적인 레이아웃 정보 보관. ㅋ블러의 크기, inode의 개수, 아이노드 수, 가용 데이터 블록 수  등등

EXT2 : 
  블록의 그룹화 : seek time을 줄이기 위해 메타데이터와 실제 데이터를 인접하게 배치하여 디스크 탐색 시간 감소
  수퍼블록의 중복 저장 : 수퍼블록을 그룹마다 중복저장하여 디스크 오류에 대비함.
  그룹 디스크립터 : 데이터 블록 비트맵의 시작 위치, 아이노드 비트맵의 시작위치. 가용 아이노드 수 등 그룹에 대한 슈퍼블록 역할.
  데이터 블록 비트맵 : 앞서 설명된 사용중인 블록을 구분하기 위한 비트맵을 적용
  아이노드 비트맵 : 사용정인 아이노드와 빈 아이노드를 구분하기 위해 사용
  아이노드 테이블 : 실제 아이노드 저장 위치

EXT4: 현재 가장 많이 쓰이는 리눅스 파일 시스템(안드로이드에서도 사용됨). EXT2 + 저널링
  갑작스럽게 전원이 공급 중단되면 메인 메모리의 버퍼 캐쉬의 수정사항이 disk에 반영되던 도중, 일부만 적용되고 나머지는 날아갈수도 있다. 이렇게 데이터가 깨져버리면 완전히 파일이 망가질수도 있다. (일관성 훼손 inconsistency)
 이를 해결하기 위해 저널링이 만들어졌다.
 journaling : 버퍼 캐시에 올라온 데이터가 수정된 경우, 버퍼캐시에서 나갈때 disk의 내용을 수정해주지 않고 5~30초 단위로 주기적으로 저널 영역이라는 별도의 위치에 수정된 내용을 저장하는 행위.
 Checkpointing: 저널링 된 데이터는 온전히 저널링 되면 일종의 인증 마크같은게 생성되어 저널 영역의 데이터가 온전한 데이터라는 것을 시스템이 알수 있게 해준다. 그러면 이를 다시 원본 데이터 위치에 수정하는 작업을 checkpointing이라고 한다.
 이를 사용하면 설령 저널 영역의 데이터를 원본에 저장하는 과정에서 전원이 나가더라도, 저널 영역을 참조해서 다시 수정하면 되기에 파일의 깨짐을 방지할수 있다.

저널링의 두가지 방법
1. 메타데이터만 저널링 (기본값)
 저널링 주기가 도래하면 데이터를 파일 시스템에 저장한 후 메타데이터를 저널영역에 기록
 체크포인팅 주기가 도래하면 메타데이터 파일시스템에 반영
 크래쉬 발생시 파일 시스템 자체가 깨지는 것을 방지(일부 데이터 훼손 가능성 있음)
2. 메타데이터 + 일반 데이터 모드 저널링
 저널링 주기가 도래하면 모두 저널영역에 기록
 체크포인팅 주기가 도래하면 모두 파일시스템에 반영
 크래쉬 발생 시 데이터 자체의 복구 보장

버퍼캐시 교체 알고리즘
LRU 와 LFU가 아닌 알고리즘들도 존재. 대표적인것 하나만.
LRFU 알고리즘
캐시 블록을 사용 빈도와 마지막 사용 시간을 고려한 가치 평가 계산식을 이용해 가장 가치평가값이 낮은 블록을 삭제하는 방식.
얼마나 최근 것까지 기록하고 있을 것인가? 어떤 버퍼 캐시를 쫓아낼지 결정하기 위해 시간이 얼마나 걸리는가?를 고려
1번은 과거 특정 계산된 가치값만 있으면 그로부터 흐른 시간을 이용해서 블록의 가치를 계산할수 있다. 이를 통해 많은 기록으로 인한 공간 낭비 해결
2번은 재참조되지 않았다면 가치는 변하지 않는다는 절대 명제를 이용해서 과거 특정 시점에 평가된 블록들의 가치관계가 변하지 않았다는 것을 이용해서 가치가 낮은 블록을 찾을수 있음. heap구조로 만들어 재참조 될때마다 자식하고만 비교해서 가치가 더 큰지 작은지만 비교하면 되기에 시간이 적게 걸린다. O(log2 n) 의 시간이 걸림.
최고의 알고리즘은 아님. 그냥 예시로 든것일 뿐