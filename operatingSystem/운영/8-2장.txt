페이징
프로그램을 구성하는 메모리는 동일한 크기로 잘라서 같은 크기로 나눠둔 물리적인 메모리(프레임)에 올리는 기법.
page table : 분할된 논리적 메모리가 물리적 메모리의 어디 주소에 들어가있는지 나타냄. 페이지 테이블은 분할된 페이지의 개수만큼 테이블의 엔트리(로우)가 생김.
cpu가 논리적인 주소를 찾고자 하면 페이지 테이블에서 맞는 물리적 주소로 변환하여 데이터를 찾아옴.
페이지 내부의 오프셋의 주소(세부 데이터의 주소)는 똑같기에 변환할 필요 없음.

페이지 테이블의 용량은 엄청 커짐. 그렇기에 메모리에 저장.
따라서 모든 메모리 접근 연산에는 2번의 memory access가 필요
페이징 기법에서 레지스터는
Page-table base register(PTBR), Page-table lenght registe(PTLR) 로 사용됨
PTBR : 메모리상에 page table이 어디있는지 가르킴.
PTLR : 페이지 테이블의 크기를 보관(리미트)
속도 향상을 위해 associative register 혹은 tlb라는 일종의 고속의 캐쉬 하드웨어를 사용.
TLB : 메모리 주소 변환을 위한 별도의 캐시 메모리를 가지고 있음. 페이지 테이블에서 빈번히 조회되는 일부 엔트리를 캐시하고 있음. 그래서 먼저 테이블에 접근하기 전 tlb에서 먼저 조회를 해서 존재하면 바로 주소 변환하는 방식. 이를 사용하면 메모리 접근은 한번만 이뤄짐.
페이지 테이블은 순서대로 배열로서 저장되기 때문에 물리적 주소만 담고 있으며 알아서 그게 n번째 논리적 주소에 대한 물리적 주소가 되지만, tlb는 모든 논리적 주소를 가지고 있는것이 아니기에 논리적 주소와 물리적 주소를 쌍으로 가지고 있어야 함.
tlb는 전체 검색을 해야하기에 속도를 위해 병행 검색을 지원.
페이지 테이블은 각각의 프로세스마다 존재. 
tlb에 있는 정보는 context switch가 생길때마다 flush, 즉 싹다 비움.

tow-level page table(이단계 페이지 테이블)
페이지 테이블 로우 하나 하나 안에 테이블이 하나씩들 더 있음.
페이지 테이블의 공간을 줄이는 것이 목적. 시간은 더 걸림.
현대 컴퓨터에서는 메모리공간이 큰 프로그램도 지원.
예를 들어 32비트 주소를 사용하면 32비트로 표현 가능한 서로 다른 표현식, 즉, 2의 32승까지의 메모리 주소를 매길수 있고, 메모리는 1칸당 1바이트이기에 1기가 *4 = 4기가까지 사용 가능. 즉, 논리적 주소, 프로세스의 주소를 4기가까지 사용 가능.
2의 10승 : k(킬로)
2의 20승 : m(메가)
2의 30승 : g(기가)
만약 4g의 프로그램을 4kb로 자르면 1m(백만)개의 페이지 테이블 엔트리가 생김.
또한 각 page entry의 크기가 4b이면 프로세스당 4m의 페이지 테이블이 필요.
문제는 대부분의 프로그램들이 4g나 사용하지 않음. 공간 낭비가 심함.
그런데 중간에 사용되지 않는 주소가 있다고 하더라도 페이지 테이블은 배열이기 때문에 중간도 다 사용해야 함.
일단계는 낭비.
이단계는 페이지 테이블에 바깥쪽 테이블 번호, 안쪽 테이블 번호, 오프셋 번호로 구성됨.
안쪽 페이지 테이블의 크기는 페이지의 크기와 같다.
페이지의 크기가 4kb라고 가정하면, 오프셋은 4kb로 표현할수 있는 표현의 개수이므로 4kb = 2의 12승 * 1byte;
따라서 2진수로 12자리수까지 표현 가능. 오프셋은 12비트.
안쪽 페이지 테이블의 엔트리 숫자는 1k개. 따라서 안쪽 테이블의 엔트리를 가르키는 페이지 번호는 10비트.
바깥쪽은 페이지 테이블의 페이지 번호는 남은 10비트.
64비트 주소체계 한번 내가 계산해보기!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
이단계 페이지 테이블을 사용하면 사용되지 않는 논리적 메모리 주소에 대한 페이지 테이블이 만들어지지 않기 때문에 공간적 이득.
